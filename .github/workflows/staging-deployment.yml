name: Staging Deployment Pipeline (reuse existing Postgres + tag fallback)

on:
  workflow_dispatch:
    inputs:
      image_sha:
        description: 'Image SHA to deploy (falls back to latest if missing)'
        required: true
        default: 'latest'
  push:
    branches: [ main ]

env:
  AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}   # e.g. btjcommerceacr.azurecr.io
  REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}                 # e.g. btjcommerceacr
  REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}                 # ACR password (or SP with AcrPull)
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}         # 7af663eb-f33a-4bfb-8590-39fea237804d
  STAGING_RESOURCE_GROUP: ${{ secrets.STAGING_RESOURCE_GROUP }}       # e.g. ecommerce-staging-rg
  LOCATION: australiaeast

  # Existing Postgres server (shared with prod)
  PG_SERVER_RG: ecommerce-production-rg
  PG_SERVER_NAME: btj-ecommerce-postgres

jobs:
  create-staging-infrastructure:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Select subscription
        run: az account set --subscription "${{ env.AZURE_SUBSCRIPTION_ID }}"

      - name: Ensure Staging Resource Group (australiaeast)
        run: az group create --name "${{ env.STAGING_RESOURCE_GROUP }}" --location "${{ env.LOCATION }}"

      - name: Register providers (idempotent)
        run: |
          az provider register -n Microsoft.DBforPostgreSQL || true
          az provider register -n Microsoft.Network || true
          az provider register -n Microsoft.ContainerInstance || true

      # CREATE STAGING DATABASES (on existing server)
      - name: Create staging databases on existing Postgres
        id: pgdb
        shell: bash
        run: |
          set -euo pipefail
          SERVER_RG="${{ env.PG_SERVER_RG }}"
          SERVER_NAME="${{ env.PG_SERVER_NAME }}"

          # Stable staging DB names so repeated runs are predictable
          DB_CUST="customer_db_stg"
          DB_ORD="order_db_stg"
          DB_PROD="product_db_stg"

          echo "Ensuring databases exist on server $SERVER_NAME in RG $SERVER_RG ..."
          az postgres flexible-server db create --resource-group "$SERVER_RG" --server-name "$SERVER_NAME" --database-name "$DB_CUST" --only-show-errors || true
          az postgres flexible-server db create --resource-group "$SERVER_RG" --server-name "$SERVER_NAME" --database-name "$DB_ORD"  --only-show-errors || true
          az postgres flexible-server db create --resource-group "$SERVER_RG" --server-name "$SERVER_NAME" --database-name "$DB_PROD" --only-show-errors || true

          echo "db_customer=$DB_CUST" >> "$GITHUB_OUTPUT"
          echo "db_order=$DB_ORD"     >> "$GITHUB_OUTPUT"
          echo "db_product=$DB_PROD"  >> "$GITHUB_OUTPUT"

      # PREFLIGHT: pick tag (prefer input sha, fallback to latest if missing in ANY repo)
      - name: Pick image tag (prefer input SHA, fallback to latest if missing)
        id: picktag
        shell: bash
        run: |
          set -euo pipefail
          ACR="${{ env.AZURE_CONTAINER_REGISTRY }}"             # e.g., btjcommerceacr.azurecr.io
          ACR_NAME="$(echo "$ACR" | cut -d. -f1)"               # e.g., btjcommerceacr
          REPOS=("product-service" "customer-service" "order-service" "frontend")
          WANT="${{ github.event.inputs.image_sha || github.sha }}"

          echo "Requested image tag: $WANT"
          az acr login --name "$ACR_NAME"

          missing=0
          for r in "${REPOS[@]}"; do
            found=$(az acr repository show-tags -n "$ACR_NAME" --repository "$r" \
              --query "contains(@, '$WANT')" -o tsv || echo false)
            echo "Repo $r has tag $WANT ? $found"
            if [ "$found" != "true" ]; then
              missing=1
            fi
          done

          if [ "$missing" -eq 1 ]; then
            echo "At least one repo is missing tag '$WANT'. Falling back to 'latest' for all."
            USE="latest"
          else
            USE="$WANT"
          fi

          echo "Using image tag: $USE"
          echo "tag=$USE" >> "$GITHUB_OUTPUT"

      - name: Create Staging RabbitMQ (DNS in australiaeast)
        run: |
          az container create \
            --resource-group "${{ env.STAGING_RESOURCE_GROUP }}" \
            --name "staging-rabbitmq-${{ github.run_id }}" \
            --image rabbitmq:3-management \
            --ports 5672 15672 \
            --cpu 1 --memory 1 \
            --os-type Linux \
            --ip-address public \
            --dns-name-label "staging-rmq-${{ github.run_id }}" \
            --restart-policy Always

      - name: Create Staging ACIs (all :8000 + DNS; reuse existing Postgres)
        shell: bash
        run: |
          set -euo pipefail
          RG="${{ env.STAGING_RESOURCE_GROUP }}"
          REGION="${{ env.LOCATION }}"
          ACR="${{ env.AZURE_CONTAINER_REGISTRY }}"
          ACR_USER="${{ env.REGISTRY_USERNAME }}"
          ACR_PASS="${{ env.REGISTRY_PASSWORD }}"
          TAG="${{ steps.picktag.outputs.tag }}"

          # Existing server connection
          PG_HOST="${{ secrets.STAGING_POSTGRES_HOST }}"           # btj-ecommerce-postgres.postgres.database.azure.com
          PG_USER="postgres"
          PG_PASS="${{ secrets.postgress_passsowrd }}"             # <-- your secret

          DB_CUST="${{ steps.pgdb.outputs.db_customer }}"
          DB_ORD="${{ steps.pgdb.outputs.db_order }}"
          DB_PROD="${{ steps.pgdb.outputs.db_product }}"

          RMQ_FQDN="staging-rmq-${{ github.run_id }}.$REGION.azurecontainer.io"

          # PRODUCT
          az container create \
            --resource-group "$RG" \
            --name "staging-product-service-${{ github.run_id }}" \
            --image "$ACR/product-service:$TAG" \
            --ports 8000 \
            --cpu 1 --memory 1.5 \
            --os-type Linux \
            --ip-address public \
            --dns-name-label "staging-product-${{ github.run_id }}" \
            --environment-variables \
              POSTGRES_USER="$PG_USER" \
              POSTGRES_DB="$DB_PROD" \
              POSTGRES_HOST="$PG_HOST" \
              POSTGRES_PORT=5432 \
              RABBITMQ_HOST="$RMQ_FQDN" \
              RABBITMQ_PORT=5672 \
              RABBITMQ_USER=guest \
            --secure-environment-variables \
              POSTGRES_PASSWORD="$PG_PASS" \
              RABBITMQ_PASS=guest \
            --registry-login-server "$ACR" \
            --registry-username "$ACR_USER" \
            --registry-password "$ACR_PASS" \
            --restart-policy Always

          # CUSTOMER
          az container create \
            --resource-group "$RG" \
            --name "staging-customer-service-${{ github.run_id }}" \
            --image "$ACR/customer-service:$TAG" \
            --ports 8000 \
            --cpu 1 --memory 1.5 \
            --os-type Linux \
            --ip-address public \
            --dns-name-label "staging-customer-${{ github.run_id }}" \
            --environment-variables \
              POSTGRES_USER="$PG_USER" \
              POSTGRES_DB="$DB_CUST" \
              POSTGRES_HOST="$PG_HOST" \
              POSTGRES_PORT=5432 \
              RABBITMQ_HOST="$RMQ_FQDN" \
              RABBITMQ_PORT=5672 \
              RABBITMQ_USER=guest \
            --secure-environment-variables \
              POSTGRES_PASSWORD="$PG_PASS" \
              RABBITMQ_PASS=guest \
            --registry-login-server "$ACR" \
            --registry-username "$ACR_USER" \
            --registry-password "$ACR_PASS" \
            --restart-policy Always

          # ORDER (points to other services via FQDN)
          PRODUCT_FQDN="staging-product-${{ github.run_id }}.$REGION.azurecontainer.io"
          CUSTOMER_FQDN="staging-customer-${{ github.run_id }}.$REGION.azurecontainer.io"

          az container create \
            --resource-group "$RG" \
            --name "staging-order-service-${{ github.run_id }}" \
            --image "$ACR/order-service:$TAG" \
            --ports 8000 \
            --cpu 1 --memory 1.5 \
            --os-type Linux \
            --ip-address public \
            --dns-name-label "staging-order-${{ github.run_id }}" \
            --environment-variables \
              POSTGRES_USER="$PG_USER" \
              POSTGRES_DB="$DB_ORD" \
              POSTGRES_HOST="$PG_HOST" \
              POSTGRES_PORT=5432 \
              RABBITMQ_HOST="$RMQ_FQDN" \
              RABBITMQ_PORT=5672 \
              RABBITMQ_USER=guest \
              PRODUCT_SERVICE_URL="http://$PRODUCT_FQDN:8000" \
              CUSTOMER_SERVICE_URL="http://$CUSTOMER_FQDN:8000" \
            --secure-environment-variables \
              POSTGRES_PASSWORD="$PG_PASS" \
              RABBITMQ_PASS=guest \
            --registry-login-server "$ACR" \
            --registry-username "$ACR_USER" \
            --registry-password "$ACR_PASS" \
            --restart-policy Always

          # FRONTEND
          az container create \
            --resource-group "$RG" \
            --name "staging-frontend-${{ github.run_id }}" \
            --image "$ACR/frontend:$TAG" \
            --ports 80 \
            --cpu 1 --memory 1 \
            --os-type Linux \
            --ip-address public \
            --dns-name-label "staging-frontend-${{ github.run_id }}" \
            --registry-login-server "$ACR" \
            --registry-username "$ACR_USER" \
            --registry-password "$ACR_PASS" \
            --restart-policy Always

      - name: Wait for Services to be Ready
        run: sleep 60

      - name: Cleanup Staging Infrastructure (ACI only)
        if: always()
        run: az group delete --name "${{ env.STAGING_RESOURCE_GROUP }}" --yes --no-wait
